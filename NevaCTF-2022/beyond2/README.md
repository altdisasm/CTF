# Beyond2
Описание не дает никакой информации. Достаточно знать, что задание относится к категории Pwn. Если вы разобрались с 2мя предыдущими заданиями, это поможет в ршении этого.

Итак, у нас есть [файл](/NevaCTF-2022/beyond2/files/beyond2), с названием beyond2 и команда для подключения к удаленному серверу.
Можно сразу догадаться что файл исполняемый, но лучше на всякий случай убедиться в этом. Для этого можно выполнить следующую команду в папке с файлом.

```
$ file beyond2
```
Результат выполнения команды:

![File command](/NevaCTF-2022/beyond2/img/file.PNG)

Далее можно запустить файл, чтобы посмотреть как ведет себя программа. Программа предлагает выбрать один из 3х пунктов, при выборе 1го или 3го просто печатает строку и заканчивает работу. При выборе 2го просит ввести что-нибудь 3 раза, и печатает ввод.

![Behavior](/NevaCTF-2022/beyond2/img/prog.PNG)

Взаимодействие с программой осуществляется всего в 2х местах, в момент выбора пункта и при выборе второго пункта (Write or read anything), когда нам предлагается записать или прочитать что-нибудь. В этом сообщении содержится небольшая подсказка, флаг действительно можно прочитать. Чтобы понять это, нужно выполнить декомпиляцию и проанализировать участки взаимодейсвтия с программой.

Декомпилированная функция main имеет следующий вид.

![Decompile](/NevaCTF-2022/beyond2/img/decomp.PNG)

Код не большой, всего несколько переменных.

- `char local_58 [72]` - буфер для текста, который пользователь вводит при выборе второго пункта

Это можно понять из 33 строки.

```
fgets(local_58,0x40,stdin);
```

- `int local_10` - хранит номер пункта, выбранного на первом этапе взаимодействия
- `int local_c` - просто счетчик итераций в цикле for, строка 31

```
for (local_c = 0; local_c < 3; local_c = local_c + 1) {
```

В этом цикле пользователь втрой раз взаимодействует с программой. Программа ждет от пользователя ввод, который попадает в буфер (переменная `local_58`) размером 72, после чего печатает полученную строку функцией **`printf`**.

Остается последняя переменная, `int iVar1`.
На самом деле это переменная типа string, в цикле с 16й по 19ю строки выполнятся ее инициализация, значением `FLAG_HERE`.


![Decompile](/NevaCTF-2022/beyond2/img/FLAG_HERE.PNG)

Проще было бы заметить это при исполнении программы под дебагером. Это значение есть на стеке.

![Flag on Stack](/NevaCTF-2022/beyond2/img/flag.PNG)

Реальный флаг лежит на сервере в том же месте (по тому смещению) относительно начала программы, осталось понять как его прочитать. Для этого достаточно знать 3 факта:

1. Флаг лежит на стеке.
2. Пользователь может управлять выводом программы.
2. Ранее упомянутая функция **`printf`**, которая отвечает за вывод - уязвима.


Чтобы полностью понять что происходит далее необходимо знать что собой представляет **уязвимость форматной строки**!!! Исрользуйте свои навыки гугления.

Тут нам достаточно того факта, что управляя выводом программы, используя эту уязвимость, можно читать значения со стека. Для этоого:

1. Запускаем программу и выбираем второй пункт.
2. Подаем на ввод следующую строку

```
%p_%p_%p_%p_%p_%p_%p_%p_%p
```

В результате получаем на выводе уже знакомые байты.

![Flag on Stack](/NevaCTF-2022/beyond2/img/solution.PNG)

Остается только поменять порядок байт с **little-endian** на **big-endian** и предствить их в **ASCII** кодировке.

![Final](/NevaCTF-2022/beyond2/img/final.PNG)

## Well done!!!


